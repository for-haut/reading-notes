# HTTP Keep-Alive

+ HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。
+ HTTP长连接不可能一直保持，例如： Keep-Alive：timeout=5， max=100， 表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。
+ HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive没能改变这个结果。另外，Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的，在HTTP1.1版本中也是如此。唯一能保证的是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于Keep-Align的保持连接特性，否则会有意想不到的后果。
+ 使用长连接之后，客户端、服务器端怎么知道本次传输结束呢？两部分：1、判断传输数据是否达到了Content-Length指示的大小；2、动态生成的文件没有Content-Length，它是分块传输的（chunked），这时候就要根据chunked编码来判断，chunked编码的数据在最后有一个空chunked块，表明本次传输数据结束。

### Transfer-Encoding

Transfer-Encoding时一个用来标示HTTP报文传输格式的头部值。尽管这个取值理论上可以有很多，但是当前的HTTP规范里实际上定义了一种传输取值--chunked

如果一个HTTP请求（请求消息或者应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。

每一个非空的块都以该块包含数据的字节数（字节数以16进制表示）开始，跟随一个CRLF（回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填有白空格。

最后一块是单行，由块大小（0），一些可选的填充空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。消息最后以CRLF结尾。

**注意：**

+ chunked和multipart两个名词在意义上有类似的地方，不过在HTTP协议当中这两个概念则不是一个类别的。multipart是一种Content-type，表示HTTP报文内容的类型，而chunked是一种传输格式，标示报头将以何种方式进行传输。
+ chunked传输不能事先知道内容的长度，只能靠最后的空chunk块来判断，因此对于下载请求来说，是没有办法实现进度的。在浏览器和下载工具中，偶尔我们也会看到有些文件是看不到下载进度的，即采用chunked方式进行下载。
+ chunked的优势在于，服务器端可以边生成内容边发送，无需事先生成全部的内容。HTTP/2不支持Transfer-Encoding：chunked，因为HTTP/2有自己的streaming传输方式。

### HTTP Pipelining（HTTP管线化）

HTTP pipelining（管线化）是将多个HTTP请求整批提交的技术，在传送过程中不需等待服务端的回应。使用HTTP Pipelining技术之后，某个连接上的消息变成了类似这样 `请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3`.

注意以下几点：

+ 管线化机制通过持久连接（persistent connection）完成，仅HTTP/1.1支持此类技术（HTTP/1.0不支持）
+ 只有GET和HEAD请求可以进行管线化，而POST有限制。
+ 初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议。
+ 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变。
+ HTTP/1.1要求服务器端支持管线化，但并不是要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可。
+ 由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如Chrome和Firefox默认并未开启管线化支持。

### 绘画跟踪

会话：

客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。

会话跟踪：

会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。

为什么需要会话跟踪？

浏览器与服务器之间的通信时通过HTTP协议进行通信的，而HTTP协议是“无状态”的协议，它不能保存客户信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。

1、会话跟踪常用的方法：

+ URL重写

	URL（统一资源定符）是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标示该会话，把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。

+ 隐藏表单域

	将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示
	
+ Cookie

	Cookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端，在客户端可以进行保存，以便下次使用。
	
	客户端可以采用两种方式来保存这个Cookie对象，一种方式是保存在客户端内存中，称为临时Cookie，浏览器关闭后这个Cookie对象将消失。另外一种方式时保存在客户机的磁盘上，称为永久Cookie。以后客户端只要访问该网站，就会将这个Cookie再次发送到服务器上，前提是这个Cookie在有效期内，这样就实现了对客户的跟踪。
	
	Cookie是可以被禁止的。
	
+ Session：

	每一个用户都有一个不同的session，各个用户之间是不能共享的，是每个用户所独享的，在session中可以存放信息。
	
	在服务器端会创建一个session对象，产生一个sessionID来标识这个session对象，然后将这个sessionID放入到Cookie中发送到客户端，下一次访问时，sessionID会发送到服务器，在服务器端进行识别不同的用户。
	
	Session的实现依赖于Cookie，如果Cookie被禁用，那么session也将失效。
	
### 跨站攻击

+ CSRF（Cross-site request forgery，跨站请求伪造）
	CSRF（XSRF）顾名思义，是伪造请求，冒充用户在站内的正常操作。
	
**如何防范CSRF攻击？**

+ 关键操作只接受POST请求
+ 验证码

	CSRF攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。
	
	但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者注册的时候使用。
	
+ 检测 Referer

	常见的互联网页面与页面之间存在联系的，比如你在www.baidu.com应该找不到通往www.google.com的连接的，再比如你 在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含浏览的输入框，这个之前的网址就会保留在新页面头文件的Referer中。
	
	通过检查Referer的值，我们就可以判断这个请求是合法的还是非法的，但是问题出现在服务器不是任何时候都能接受到Referer的值，所以Referer Check一般用于监控CSRF攻击的发生，而不用来抵御攻击。

+ Token

	目前主流的做法是使用Token抵御CSRF攻击。下面通过分析CSRF攻击来理解为什么Token能够有效。
	
	CSRF攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止CSRF攻击。
	
	另一个更通用的做法是保持原有的参数不变，另外添加一个参数Token，其值是随机的。这样攻击者因为不知道Token而无法构造出合法的请求进行攻击。
	
	Token使用原则
	
		+ Token要足够随机---只有这样才算不可预测
		+ Token是一次性的，即每次请求成功后要更新Token---这样可以增加攻击难度，增加预测难度。
		+ Token 要注意保密性---敏感操作使用post，防止Token出现在URL中
		**注意：**过滤用户输入的内容不能阻挡csrf，我们需要做的事过滤请求的来源。
		
+ XSS（Cross Site Scripting，跨站脚本攻击）

XSS全称“跨站脚本攻击”，是注入攻击的一种。其特点是不对服务器造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有JavaScript的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。
