# js设计模式

### 三大类：

+ **创建型模式：**

单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式

+ **结构型模式：**

适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式

+ **行为型模式：**

模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式】职责链模式、访问者模式。

### why为什么使用模式：

少走弯路，提升效率

### how 怎么用设计模式：

使用设计模式的六大原则：

1. 单一职责原则(srp) Single Responsibility Principle

	+ 应该有且仅有一个原因引起类的变更。简单点说，**一个方法，只做一件事情**。

2. 里氏代换原则(LSP) Liskov Substitution Principle

	+ 超类、父类，或者父类的父类。父类能去的地方子类也可以去。

3. 依赖倒置原则(DIP) Dependence Inversion Principle

	+ 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
	+ 接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类。这一点其实不用多说，很好理解，“面向接口编程”思想正是这点的最好体现。

4. 接口隔离原则(ISP) InterfaceSegregation Principles

	+ 其一是不应该强行要求客户端依赖于它们不用的接口；其二是类之间的依赖应该建立在最小的接口上面。简单点说，客户端需要什么功能，就提供什么接口，对于客户端不需要的接口不应该强行要求其依赖；类之间的依赖应该建立在最小的接口上面，这里最小的粒度取决于单一职责原则的划分。
	+ 不应该强行要求客户端依赖于它们不用的接口。语句很好理解，即客户端需要什么接口，就依赖什么接口，不需要的就不依赖。那么我们反过来说，如果客户端依赖了它们不需要的接口，那么这些客户端程序就面临不需要的接口变更引起的客户端变更的风险，这样就会增加客户端和接口之间的耦合程度，显然与“高内聚、低耦合”的思想相矛盾。
	+ 类之间的依赖应该建立在最小的接口上面。何为最小的接口，即能够满足项目需求的相似功能作为一个接口，这样设计主要就是为了“高内聚”。那么我们如何设计最小的接口呢？那就要说说粒度的划分了，粒度细化的程度取决于我们上一章讲的的单一职责原则里面接口划分的粒度。从这一点来说，接口隔离和单一职责两个原则有一定的相似性。

5. 迪米特法则LOD Law of demeter

	+ 也称为最少知识原则(least Knowledge Principle)
	+ 一个对象应该对其他对象有最少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道的知道的最少。

6. 开闭原则(OCP) Open Close Principle

	+ 软件中的对象(类、模块、函数等)应该对于扩展是开放的，但是对于修改是封闭的。简单来讲就是：对扩展开放，对修改关闭。

	
## 结构型模式-设计对象的结构和关系

+ 适配器模式
+ 桥接模式
+ 装饰模式
+ 组合模式
+ 外观模式
+ 享元模式
+ 代理模式
	+ 为一个对象提供一种代理以控制对这个对象的访问
	+ 代理对象起到类似中介的作用，会增加一些功能（） 

### 行为模式-设计对象的行为

模版方式模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式，访问者模式。

### 设计模式的六大原则

减少耦合，增强复用性，降低代码的开发纬度和扩展成本

### 耦合度和复杂度的危害性

+ 复杂度： 高，代码质量不高，可维护性差，复用性差，不易扩展
+ 耦合度：无不可能，低合理，过高不容易维护。但复用性和扩展性是好的。

### 开发时的流程

+ 优先降低复杂度，尽量降低耦合度。
+ 利用单一职责原则，开闭原则，里氏代换原则，降低复杂度。
+ 通过迪米特法则减少耦合度。
+ 通过依赖倒置原则消除可以没有的耦合。


